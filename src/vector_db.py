# vector_db.py
from random import random
import sqlite3
from annoy import AnnoyIndex
import msgpack
from typing import List
from data_object import DataObject

VECTOR_DIMENSION = 3

class VectorDB:
    def __init__(self, db_path: str = "src/vector_data.db"):
        self.db_path = db_path
        self.index = AnnoyIndex(VECTOR_DIMENSION, "angular")
        self.id_map = {}

    def _connect(self):
        return sqlite3.connect(self.db_path)



    def save_index(self, file_name: str):
        self.index.build(10)  # Number of trees, higher values give better accuracy but longer build time
        self.index.save(file_name)

    def load_index(self, file_name: str):
        self.index.load(file_name)

    def add_entry(self, entry: DataObject):
        with self._connect() as conn:
            cursor = conn.cursor()
            serialized_vector = msgpack.packb(entry.vector)
            cursor.execute("INSERT INTO vector_data (timestamp, message, vector) VALUES (?, ?, ?)",
                        (entry.timestamp, entry.message, serialized_vector))
            entry.id = cursor.lastrowid # Get the autogenerated ID
            conn.commit()

            integer_id = len(self.id_map)
            self.id_map[entry.id] = integer_id
            self.index.add_item(integer_id, entry.vector)

    def get_entry(self, id: int) -> DataObject:
        with self._connect() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM vector_data WHERE id = ?", (id,))
            result = cursor.fetchone()

        if result:
            entry_id, timestamp, message, serialized_vector = result
            vector = msgpack.unpackb(serialized_vector)
            return DataObject(timestamp=timestamp, message=message, id=entry_id, vector=vector)
        else:
            return None

    def delete_entry(self, id: int):
        with self._connect() as conn:
            cursor = conn.cursor()
            cursor.execute("DELETE FROM vector_data WHERE id = ?", (id,))
            conn.commit()

    def update_entry(self, entry: DataObject):
        with self._connect() as conn:
            cursor = conn.cursor()
            serialized_vector = msgpack.packb(entry.vector)
            cursor.execute("UPDATE vector_data SET timestamp = ?, message = ?, vector = ? WHERE id = ?",
                        (entry.timestamp, entry.message, serialized_vector, entry.id))
            conn.commit()

    def search_entries(self, vector: List[float], num_results: int = 10) -> List[DataObject]:
        nearest_integer_ids = self.index.get_nns_by_vector(vector, num_results)
        nearest_ids = [list(self.id_map.keys())[list(self.id_map.values()).index(integer_id)] for integer_id in nearest_integer_ids]

        entries = []
        for entry_id in nearest_ids:
            entry = self.get_entry(entry_id)
            if entry:
                entries.append(entry)

        return entries



if __name__ == "__main__":
    # Example usage
    from datetime import datetime
    from word_generator import generate_sentence

    # Test the API
    db = VectorDB()

    new_sentence = generate_sentence()

    # Create a new entry
    entry = DataObject(timestamp=datetime.now(), message=new_sentence, vector=[random() for _ in range(3)])
    db.add_entry(entry)

    # save the index
    db.save_index("vector_index.ann")

    # Load the index
    db.load_index("vector_index.ann")

    # Search for entries
    entries = db.search_entries(vector=entry.vector, num_results=10)

    # perfomr simularirty search
    query_vector = [0.1, 0.2, 0.3]
    search_resuts = db.search_entries(query_vector, num_results=10)
    print(f'Search results for {query_vector}:')
    for result in search_resuts:
        print(result.__dict__)
